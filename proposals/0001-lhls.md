### ROUGH DRAFT
##### Nothing is complete & everything is subject to change.

- Feature Name: Low-Latency Streaming
- Start Date: 2018-08-18
- RFC PR: (leave this empty)
- Hls.js Issue: (leave this empty)

# Summary
[summary]: #summary

Low-latency HLS (LHLS) proposes to reduce the latency from the edge of a live stream. Hls.js incurs significant latency penalties from it's current architecture; and also incurs another penalty from the current method of delivering segments over HTTP. This RFC proposes modifications to Hls.js's architecture to support progressive downloading, parsing, and buffering of media segments. This proposal also aims to gain consensus on how transcoders shall signal and deliver LHLS streams to Hls.js so as to reduce latency.

# Motivation
[motivation]: #motivation

The current latency between capture and playback ("glass to glass") is prohibitive for live interactivity, and provides a poor experience for time-sensitive live events (such as sports). The introduction of low-latency streaming via HTTP in Hls.js would allow developers to build a cost-effective solution on top of a free, open, and proven client.

Furthermore, the introduction of a progressive streaming pipeline in Hls.js would improve performance not only for live but for VOD. Progressively buffering segments allows Hls.js to reduce its TTFF (time to first frame), and by the same token reduce the rebuffering time caused by network instability.

# Guide-Level Explanation
[guide-level-explanation]: #guide-level-explanation


Low-latency streaming is used by Hls.js to stream MPEGTS segments which have not completed transcoding yet. Segments do not need to be complete to be buffered - each segment contains a number of GOPs (group of pictures), and each GOP can be independently transmuxed and appended to MSE. Using HTTP chunked transfer encoding, Hls.js is able to maintain a persistent connection with a transcoding server; the server, in turn, is able to push partial segments to the client before completion. Additional reductions in latency are possible by negotiating the TCP connection ahead of time the segment needs to be buffered.


Hls.js takes advantage of this feature when it detections a custom HLS tag preceding a segment URL. When Hls.js sees this tag, it makes a request using the Fetch API with streaming body responses. Each time Hls.js receives a chunk of data, it passes it through it's transmuxing pipeline so that it may be buffered. Any samples which cannot be decoded using the information in the present chunk are saved so that they may be used in the next. In this way Hls.js is able to stream segments through it's pipeline instead of waiting for the whole segment to be available first.

Hls.js offers the developer the option to disable or enable low-latency streaming even while Hls.js is playing. This is made possible by the structure of the low-latency manifest. In addition to segments which are not available, an LHLS manifest also advertises segments which are available for direct playback. These segments conform to the HLS spec and require no extra work to buffer. When low-latency mode is disabled, Hls.js simply ignores any future-advertised segments. It is this feature that allows Hls.js to continue to function in browsers which do not support low-latency streaming, without requiring two versions of a manifest.
  
This RFC proposes changes to the top-level API of Hls.js and also organizes the sub-subystem RFCs broken out from the main story. Please see the sections below for links to the sub-system RFCs.


# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

This section details how Hls.js interprets a low-latency manifest. Developers wishing to use LHLS must adhere to the conventions laid out within this section. "The client" here refers to Hls.js but is worded so that any MSE-based player may fulfill the same requirements.

This spec is a superset of the HLS spec. Unless otherwise noted, all requirements and recommendations apply here.

## Glossary
- Client: An MSE-Based JS player such as Hls.js
- Server: The system comprising delivery, transcoding, cdn etc.; the party responsible for creating and serving the manifest
- Prefetch segment: A segment which has been advertised but is not yet available
- Complete segment: A segment which has been advertised and available. Any non-LHLS playlist consists only of complete segments.

## Prefetch Segment Advertising

The server may advertise zero or more prefetch segments for the live period using the `EXT-X-PREFETCH` metadata tag. These segments must appear after all complete segments. The tag must conform to the following format:

`#EXT-X-PREFETCH: ${URI}`

To each prefetch segment response, the server must append the `Transfer-Encoding: chunked` header. The server must maintain the persistent HTTP connection long enough for a client to receive the entire segment - this must be no less than the time from when the segment was first advertised to the time it takes to become available. 

Any constraint in the HLS spec applying to complete segments also applies to prefetch segments unless otherwise specified. For example:
- A segment must remain available to clients for a period of time equal to the duration of the segment plus the duration of the longest Playlist file distributed by the server containing that segment.

The client may choose to ignore prefetch segments.

### Playlist Duration

The duration of a playlist file containing prefetch segments is considered to be equal to the duration of all complete segments plus the expected duration of all prefetch segments.

## Media Segment Tags

The server must not precede any prefetch segment with metadata other than those specified in this document, with the specified constraints.

### EXTINF

A prefetch segment must not be advertised with an `EXTINF` tag. The duration of a prefetch segment must be equal to or less than what is specified by the `EXT-X-TARGETDURATION` tag. 

### EXT-X-DISCONTINUITY

A prefetch segment must not be advertised with an `EXT-X-DISCONTINUITY` tag. To insert a discontinuity just for prefetch segments, the server must insert the `EXT-X-PREFETCH-DISCONTINUITY` tag before the first `EXT-X-PREFETCH` tag of the new discontinuous range. 

A prefetch segment's Discontinuity Sequence Number is the value of the `EXT-X-DISCONTINUITY-SEQUENCE` tag (or zero if none) plus the number of `EXT-X-DISCONTINUITY` and `EXT-X-PREFETCH-DISCONTINUITY` tags in the Playlist preceding the URI line of the segment.

### EXT-X-MAP

Prefetch segments must not be advertised with an `EXT-X-MAP` tag.

### EXT-X-KEY

Prefetch segments may be advertised with an `EXT-X-KEY` tag. The key itself must be complete; the server must not expect the client to progressively stream keys.

## Transformation to Complete Segments

After the server has made a prefetch segment available for direct playback, that segment must be transformed to a complete segment. The following transform constraints must be observed:

- The server must not insert any segment between the last completed segment and the first prefetch segment.
- The server must advertise the transformed segment with the same URI used in the prefetch advertisement.
- The server must append the `EXTINF` metadata tag to the transformed segment.
- If the prefetch segment was advertised with a metadata tag, the transformed segment must be advertised with an identical or equivalent metadata tag. For example:
    - `EXT-X-PREFETCH-DISCONTINUITY` must be transformed to `EXT-X-DISCONTINUITY`
- When a prefetch segment is transformed to a complete segment, the server must not increment the `EXT-X-MEDIA-SEQUENCE` value. 
- When a prefetch discontinuity is transformed to complete discontinuity, the server must not increment the `EXT-X-DISCONTINUITY-SEQUENCE` value.

The server may advertise zero or more complete segments. 

## Measuring Latency

If a developer wishes to measure the total, or "glass-to-glass" latency of a stream, the server must add the `EXT-X-PROGRAM-DATE-TIME` (PDT) metadata to each segment, in the format detailed by [the spec](https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.6). The timestamp should be as close to capture as possible to ensure accuracy {what is a good recommendation on "as close to capture as possible?}. This metadata must not be appended to segments future advertised with the `EXT-X-PREFETCH` tag.  The client shall measure accuracy using the following equations:

```
totalLatency = playerLatency + broadcastLatency

playerLatency = lastSegment.endTime - video.currentTime

broadcastLatency = lastSegment.endTime - wallclockTime
```

Where `wallclockTime` is the current time (in browsers, this is typically measured using `Date.now()`).

Where `lastSegment` is the last normally-advertised segment in the manifest, and `endTime` is it's PDT plus duration.

If the `EXT-X-PROGRAM-DATE-TIME` timestamp is not provided, the client may advertise `playerLatency` alone, or nothing at all.

## Example Manifests

The example below is a child manifest listing two available segments and two prefetch segments.

`URL: https://foo.com/bar.m3u8`
```
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:2
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:06.531Z
#EXTINF:2.000
https://foo.com/bar/0.ts
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:08.531Z
#EXTINF:2.000
https://foo.com/bar/1.ts

#EXT-X-PREFETCH:https://foo.com/bar/2.ts
#EXT-X-PREFETCH:https://foo.com/bar/3.ts
```
The next manifest request may return: 

```
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:2
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:06.531Z
#EXTINF:2.000
https://foo.com/bar/1.ts
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:08.531Z
#EXTINF:2.000
https://foo.com/bar/2.ts

#EXT-X-PREFETCH:https://foo.com/bar/3.ts
#EXT-X-PREFETCH:https://foo.com/bar/4.ts
```

Note how the future frag `#EXT-X-PREFETCH:https://foo.com/bar/2.ts` is now advertised as an available segment with complete metadata.

## LHLS Subsystem RFCs
- [Progressive Streaming Engine]( ./0002-progressive-streaming.md)
- [Advanced Segment Downloader](./0003-advanced-segment-downloading.md)
- [LHLS-Aware ABR Controller]()
- [Live Edge Catch-Up Mechanism]()

# Drawbacks
[drawbacks]: #drawbacks

- This feature will require significant codebase changes and may introduce regressions.
- The proposed changes may make the codebase more complicated. Hls.js has an event-based architecture, in which events follow a sequential pattern (e.g. LOADING -> LOADED -> PARSED -> BUFFERED). LHLS will require events to be fired out of regular order (e.g. LOADING -> LOADING -> LOADED -> LOADING -> PARSED -> LOADED). A poor implementation may make codebase maintenance more difficult.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

## The choice of HTTP
HTTP low-latency streaming (as opposed to alternative protocols like WebRTC) allows developers to leverage existing HTTP video delivery infrastructure. It is also more straightforward to implement in Hls.js itself. However, WebRTC would further reduce latency by eliminating 

## Prefetch flavor of LHLS
This proposal details an LHLS manifest which differs from the "traditional" format, in which all segments in the manifest are intended to be progressively downloaded. In this scheme there is no differentiation between complete segments and those in the process of transcoding.

The benefits of prefetching over this scheme are:

1. Backwards compatibility. Clients which do not support LHLS will discard prefetch segments; good prefetch implementations should also have transcoded segments in-manifest for incompatible clients to play. Furthermore, transcoding services will not have to create two versions of a manifest (LHLS and not) to support all devices.
2. In-client LHLS selection. Developers will be able to disable or enable LHLS while the client is streaming. Developers may make this option available to the user so that they are able to choose an experience most beneficial to them.


And some downsides are:
1. Increased server complexity. The server must add custom metadata to the manifest, and the server must deliver (and differentiate) transcoded and prefetch segments.
2. Increased client complexity. The client must be able to utilize both future and complete segments.


## What is the cost of not doing this?
Low-latency streaming is becoming increasingly desired. Larger companies such as Akamai, Wowza, and Periscope offer low-latency streaming solutions. However, these solutions are not free or open. Not implementing this feature in Hls.js would make it more difficult for all video developers to access an easy and effective LHLS solution; if LHLS becomes a basic feature in the future, not having a FOSS solution will drive people towards a closed solution. Furthermore, developing LHLS in the open allows everyone to participate in its development.

# Supported Environments
[supported-environments]: #supported-environments

Only browsers which support the Fetch API with streaming body responses are able to support LHLS. This includes:

- Chrome >= 63
- Edge >= 16
- Safari >= 11.1
- Firefox >= 57 (only behind a flag)

# Prior art
[prior-art]: #prior-art

- https://medium.com/@periscopecode/introducing-lhls-media-streaming-eb6212948bef
- https://speakerdeck.com/stswe/cmaf-low-latency-streaming-by-will-law-from-akamai
- https://www.wowza.com/products/capabilities/low-latency

# Unresolved questions
[unresolved-questions]: #unresolved-questions

## What parts of the design do you expect to resolve through the RFC process before this gets merged?
- How to track bitrate for ABR
- How to catch up to the live edge after falling behind
- How long should the server maintain a segment connection for
- Should any functionality be made overrideable via config? If so, which ones? 
- Should the manifest only update after the prefetch frags have completed? Can prefetch frags be repeated if they are not yet completed?
- How much data does a transcoder typically push? Is one GOP enough to buffer in MSE?
- How does seeking work?
- SCTE-35 DATERANGE compatibility
- Does EXT-X-PROGRAM-DATE-TIME need a prefetch prefix
 
## What parts of the design do you expect to resolve through the implementation of this feature before stabilization?

Aside from `DISCONTINUITY`, It is not certain which tags need a prefetch prefix to ensure backwards compatibility with players that do not support this proposal. For example, we do not know how Safari's native player will handle a rogue `EXT-X-PROGRAM-DATE-TIME` tag. When test manifest are acquired, implementers must ensure that no unexpected behavior is introduced. 

## What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?
- CMAF low latency segments
