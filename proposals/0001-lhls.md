- Feature Name: Low-Latency Streaming
- Start Date: 2018-08-18
- RFC PR: (leave this empty)
- Hls.js Issue: (leave this empty)

# Summary
[summary]: #summary

Low-latency HLS (LHLS) proposes to reduce the latency from the edge of a live stream. Hls.js incurs significant latency penalties from it's current architecture; and also incurs another penalty from the current method of delivering segments over HTTP. This RFC proposes modifications to Hls.js's architecture to support progressive downloading, parsing, and buffering of media segments. This proposal also aims to gain consensus on how transcoders shall signal and deliver LHLS streams to Hls.js so as to reduce latency.

# Motivation
[motivation]: #motivation

The current latency between capture and playback ("glass to glass") is prohibitive for live interactivity, and provides a poor experience for time-sensitive live events (such as sports). The introduction of low-latency streaming via HTTP in Hls.js would allow developers to build a cost-effective solution on top of a free, open, and proven client.

Furthermore, the introduction of a progressive streaming pipeline in Hls.js would improve performance not only for live but for VOD. Progressively buffering segments allows Hls.js to reduce it's TTFF (time to first frame), and by the same token reduce the rebuffering time caused by network instability.

# Guide-Level Explanation
[guide-level-explanation]: #guide-level-explanation

 LHLS relies on the following principles:
  1. HLS segments can be described as a set of many smaller segments - each segment contains a number of GOPs (group of pictures), and each GOP can be independently transmuxed.
  2. HTTP chunked transfer encoding allows a client to maintain a persistent connection with a transcoder
  3. Transcoders can emit segment chunks as they're being transcoded
  
  Together these principles form the basis for our solution. 
   
  
  This RFC proposes changes to the top-level API of Hls.js; and also organizes the sub-subystem RFCs broken out from the main story. Please see the sections below for links to the sub-system RFCs.


# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

This section details how Hls.js interprets a low-latency manifest. Developers wishing to use LHLS must adhere to the conventions laid out within this section. "The client" here refers to Hls.js but is worded so that any MSE-based player may fulfill the same requirements.

#### Future Segment Advertising

The server may advertise zero or more future segments for the live period using the `EXT-X-PREFETCH` metadata tag. The tag must conform to the following format:

`#EXT-X-PREFETCH: ${url}`

To each future segment response, the server must append the `Transfer-Encoding: chunked` header. The server should maintain the persistent HTTP connection long enough for a client to receive the entire segment - at a minimum, this should be no less than the time from when the segment was first advertised to the time it has finished transcoding. If the server would "normally" advertise the same segment after it has once been future advertised, it must use the same URL as it did with the `EXT-X-PREFETCH` tag.

The client shall request all future segments according to the procedure defined in the Advanced Segment Downloader (see below).

#### Measuring Latency

If a developer wishes to measure the total, or "glass-to-glass" latency of a stream, their server must add the `EXT-X-PROGRAM-DATE-TIME` (PDT) metadata to each segment, in the format detailed by [the spec](https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.6). The timestamp should be as close to capture as possible to ensure accuracy {what is a good recommendation on "as close to capture as possible?}. This metadata must not be appended to segments future advertised with the `EXT-X-PREFETCH` tag.  The client shall measure accuracy using the following equations:

`totalLatency = playerLatency + broadcastLatency`

`playerLatency = lastSegment.endTime - video.currentTime`

`broadcastLatency = lastSegment.endTime - wallclockTime`

Where `wallclockTime` is the current time (in browsers, this is typically measured using `Date.now()`).

Where `lastSegment` is the last normally-advertised segment in the manifest, and `endTime` is it's PDT plus duration.


If the `EXT-X-PROGRAM-DATE-TIME` timestamp is not provided, the client may advertise `playerLatency` alone.


#### Example Manifest

The example below is a child manifest listing two normal segments and two future segments.

`URL: https://foo.com/bar.m3u8`
```
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:2
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:06.531Z
#EXTINF:2.000
https://foo.com/bar/0.ts
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:08.531Z
#EXTINF:2.000
https://foo.com/bar/1.ts

#EXT-X-PREFETCH:https://foo.com/bar/2.ts
#EXT-X-PREFETCH:https://foo.com/bar/3.ts
```
The next manifest request may return: 

```
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:2
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:06.531Z
#EXTINF:2.000
https://foo.com/bar/1.ts
#EXT-X-PROGRAM-DATE-TIME:2018-09-05T20:59:08.531Z
#EXTINF:2.000
https://foo.com/bar/2.ts

#EXT-X-PREFETCH:https://foo.com/bar/3.ts
#EXT-X-PREFETCH:https://foo.com/bar/4.ts
```

Notice how the future frag `#EXT-X-PREFETCH:https://foo.com/bar/2.ts` is now advertised as a normal segment with complete metadata.

#### LHLS Subsystem RFCs
- [Progressive Streaming Engine]( ./0002-progressive-streaming.md)
- [Advanced Segment Downloader](./0003-advanced-segment-downloading.md)
- [LHLS-Aware ABR Controller]()
- [Live Edge Catch-Up Mechanism]()

# Drawbacks
[drawbacks]: #drawbacks

- This feature will require significant codebase changes and will probably introduce regressions.
- The proposed changes may make the codebase more complicated. Hls.js has an event-based architecture, in which events follow a sequential pattern (e.g. LOADING -> LOADED -> PARSED -> BUFFERED). LHLS will require events to be fired out of regular order (e.g. LOADING -> LOADING -> LOADED -> LOADING -> PARSED -> LOADED). A poor implementation may make codebase maintenance more difficult.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

#### The choice of HTTP
HTTP low-latency streaming (as opposed to alternative protocols like WebRTC) allows developers to leverage existing HTTP video delivery infrastructure. It is also more straigtforward to implement in Hls.js itself.

#### What is the cost of not doing this?
Low-latency streaming is becoming increasingly desired. Larger companies such as Akamai, Wowza, and Periscope offer low-latency streaming solutions. However, these solutions are not free or open. Not implementing this feature in Hls.js would make it more difficult for all video developers to access an easy and effective LHLS solution; if LHLS becomes a basic feature in the future, not having a FOSS solution will drive people towards a closed solutioni. Furthermore, developing LHLS in the open allows everyone to participate in its development.

# Supported Environments
[supported-environments]: #supported-environments

Only browsers which support the Fetch API with streaming body responses are able to support LHLS. This includes:

- Chrome >= 63
- Edge >= 16
- Safari >= 11.1
- Firefox >= 57 (only behind a flag)

# Prior art
[prior-art]: #prior-art

- https://medium.com/@periscopecode/introducing-lhls-media-streaming-eb6212948bef
- https://speakerdeck.com/stswe/cmaf-low-latency-streaming-by-will-law-from-akamai
- https://www.wowza.com/products/capabilities/low-latency

# Unresolved questions
[unresolved-questions]: #unresolved-questions

#### What parts of the design do you expect to resolve through the RFC process before this gets merged?
- ~~How transcoders should signal LHLS~~
- .ts or .fmp4 support (or both)
- Handling of trickier features (e.g. discontinuities)
- How to track bitrate for ABR
- How to catch up to the live edge after falling behind
- How long should the server maintain a segment connection for
- ~~How is latency measured?~~
- Should any functionality be made overrideable via config? If so, which ones? 
- ~~Should individual segments be marked as low-latency (like Twitch's PREFETCH metadata), or should the entire stream be low-latency?~~
- Should the manifest only update after the prefetch frags have completed? Can prefetch frags be repeated?

#### What parts of the design do you expect to resolve through the implementation of this feature before stabilization?



#### What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?
- CMAF low latency segments
